{% extends "base.html" %}

{% block content %}
<h1 class="text-2xl font-semibold text-green-800 mb-6">Data Analysis & Visualization</h1>

<div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
    <div class="bg-white p-6 rounded-lg shadow-md">
        <h2 class="text-xl font-semibold text-green-800 mb-4">Model Visualization (Architecture)</h2>
        <!-- Model architecture chart generated by model_visualization.py -->
        {% if model_plot_url %}
            <img src="{{ model_plot_url }}" alt="Model Architecture Diagram" class="w-full h-80 object-contain mx-auto mb-2"/>
            <p class="text-xs text-gray-500 text-center">Generated via keras.utils.plot_model</p>
        {% else %}
            <p class="text-gray-600 text-center">Model visualization not available.</p>
        {% endif %}
    </div>
    <div class="bg-white p-6 rounded-lg shadow-md">
        <h2 class="text-xl font-semibold text-green-800 mb-4">Feature Correlation Heatmap</h2>
        <!-- Feature correlation heatmap from visualization.py -->
        {% if feature_corr_plot_url %}
            <img src="{{ feature_corr_plot_url }}" alt="Feature Correlation Heatmap" class="w-full h-80 object-contain mx-auto mb-2"/>
            <p class="text-xs text-gray-500 text-center">Generated via Seaborn (visualization.py)</p>
        {% else %}
            <p class="text-gray-600 text-center">Correlation heatmap not available.</p>
        {% endif %}
    </div>
</div>

<div class="bg-white p-6 rounded-lg shadow-md mb-6">
    <h2 class="text-xl font-semibold text-green-800 mb-4">Model Performance Comparison</h2>
    <div id="modelPerformanceChart" class="h-80"></div>
</div>

<div class="bg-white p-6 rounded-lg shadow-md mb-6">
    <h2 class="text-xl font-semibold text-green-800 mb-4">Confusion Matrix Analysis</h2>
    <div class="mb-4">
        <label for="model_select" class="block text-gray-700 mb-2">Select Model:</label>
        <select id="model_select" class="px-3 py-2 border border-gray-300 rounded-md">
            <option value="random_forest">Random Forest</option>
            <option value="gradient_boosting">Gradient Boosting</option>
            <option value="svm">Support Vector Machine</option>
            <option value="neural_network">Neural Network</option>
        </select>
        
        <label for="crop_select" class="block text-gray-700 mb-2 mt-4">Select Crop:</label>
        <select id="crop_select" class="px-3 py-2 border border-gray-300 rounded-md">
            <option value="all">All Crops</option>
            {% for crop in ['wheat', 'corn', 'rice', 'soybean', 'potato'] %}
                <option value="{{ crop }}">{{ crop|title }}</option>
            {% endfor %}
        </select>
    </div>
    <div id="confusionMatrixChart" class="h-96"></div>
</div>

<div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
    <div class="bg-white p-6 rounded-lg shadow-md">
        <h2 class="text-xl font-semibold text-green-800 mb-4">Actual vs Predicted Yield</h2>
        <div id="actualVsPredictedChart" class="h-80"></div>
    </div>

    <div class="bg-white p-6 rounded-lg shadow-md">
        <h2 class="text-xl font-semibold text-green-800 mb-4">Prediction Error Distribution</h2>
        <div id="errorDistributionChart" class="h-80"></div>
    </div>
</div>

<div class="bg-white p-6 rounded-lg shadow-md">
    <h2 class="text-xl font-semibold text-green-800 mb-4">Historical Yield Trends</h2>
    {% if historical_data is not none and not historical_data.empty %}
        <div class="mb-4">
            <label for="crop_filter" class="block text-gray-700 mb-2">Filter by Crop:</label>
            <select id="crop_filter" class="px-3 py-2 border border-gray-300 rounded-md">
                <option value="all">All Crops</option>
                {% for crop in ['wheat', 'corn', 'rice', 'soybean', 'potato'] %}
                    <option value="{{ crop }}">{{ crop|title }}</option>
                {% endfor %}
            </select>
        </div>
        <div id="yieldTrendChart" class="h-96"></div>
    {% else %}
        <p class="text-gray-600">No historical data available. <a href="{{ url_for('prediction') }}" class="text-green-600 hover:underline">Make your first prediction</a> to generate data.</p>
    {% endif %}
</div>

<!-- Loading indicator -->
<div id="loadingIndicator" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center hidden">
    <div class="bg-white p-6 rounded-lg shadow-lg">
        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-green-600 mx-auto"></div>
        <p class="mt-4 text-gray-700">Loading visualizations...</p>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const loadingIndicator = document.getElementById('loadingIndicator');
        
        // Show loading indicator
        loadingIndicator.classList.remove('hidden');
        
        // Load all visualizations
        Promise.all([
            loadModelPerformance(),
            loadConfusionMatrix(),
            loadActualVsPredicted(),
            loadErrorDistribution(),
            loadYieldTrends()
        ]).finally(() => {
            loadingIndicator.classList.add('hidden');
        });

        // Event listeners for filters
        document.getElementById('model_select').addEventListener('change', loadConfusionMatrix);
        document.getElementById('crop_select').addEventListener('change', loadConfusionMatrix);
        document.getElementById('crop_filter').addEventListener('change', loadYieldTrends);

        async function loadModelPerformance() {
            try {
                const response = await fetch('/api/model_performance');
                const data = await response.json();
                
                const models = Object.keys(data);
                const metrics = ['accuracy', 'r2_score', 'rmse'];
                const metricNames = ['Accuracy', 'RÂ² Score', 'RMSE'];
                
                const traces = metrics.map((metric, index) => ({
                    x: models,
                    y: models.map(model => data[model][metric]),
                    type: 'bar',
                    name: metricNames[index],
                    marker: {
                        color: ['#10B981', '#3B82F6', '#EF4444']
                    }
                }));
                
                const layout = {
                    title: 'Model Performance Metrics',
                    xaxis: { title: 'Models' },
                    yaxis: { title: 'Score' },
                    barmode: 'group'
                };
                
                Plotly.newPlot('modelPerformanceChart', traces, layout);
            } catch (error) {
                console.error('Error loading model performance:', error);
            }
        }

        async function loadConfusionMatrix() {
            try {
                const model = document.getElementById('model_select').value;
                const crop = document.getElementById('crop_select').value;
                
                const response = await fetch(`/api/confusion_matrix?model=${model}&crop=${crop}`);
                const data = await response.json();
                
                const trace = {
                    z: data.matrix,
                    x: ['Very Low', 'Low', 'Medium', 'High', 'Very High'],
                    y: ['Very Low', 'Low', 'Medium', 'High', 'Very High'],
                    type: 'heatmap',
                    colorscale: 'Greens',
                    showscale: true
                };
                
                const layout = {
                    title: `Confusion Matrix - ${model.toUpperCase()} (${crop})`,
                    xaxis: { title: 'Predicted Yield' },
                    yaxis: { title: 'Actual Yield' }
                };
                
                Plotly.newPlot('confusionMatrixChart', [trace], layout);
            } catch (error) {
                console.error('Error loading confusion matrix:', error);
            }
        }

        async function loadActualVsPredicted() {
            try {
                const response = await fetch('/api/actual_vs_predicted');
                const data = await response.json();
                
                const trace = {
                    x: data.actual,
                    y: data.predicted,
                    mode: 'markers',
                    type: 'scatter',
                    name: 'Predictions',
                    marker: {
                        color: '#3B82F6',
                        size: 8,
                        opacity: 0.6
                    }
                };
                
                const perfectLine = {
                    x: [Math.min(...data.actual), Math.max(...data.actual)],
                    y: [Math.min(...data.actual), Math.max(...data.actual)],
                    mode: 'lines',
                    type: 'scatter',
                    name: 'Perfect Prediction',
                    line: {
                        color: '#EF4444',
                        dash: 'dash'
                    }
                };
                
                const layout = {
                    title: 'Actual vs Predicted Yield',
                    xaxis: { title: 'Actual Yield (tons/hectare)' },
                    yaxis: { title: 'Predicted Yield (tons/hectare)' }
                };
                
                Plotly.newPlot('actualVsPredictedChart', [trace, perfectLine], layout);
            } catch (error) {
                console.error('Error loading actual vs predicted:', error);
            }
        }

        async function loadErrorDistribution() {
            try {
                const response = await fetch('/api/error_distribution');
                const data = await response.json();
                
                const trace = {
                    x: data.errors,
                    type: 'histogram',
                    name: 'Prediction Errors',
                    marker: {
                        color: '#8B5CF6'
                    },
                    opacity: 0.7
                };
                
                const layout = {
                    title: 'Prediction Error Distribution',
                    xaxis: { title: 'Error (tons/hectare)' },
                    yaxis: { title: 'Frequency' }
                };
                
                Plotly.newPlot('errorDistributionChart', [trace], layout);
            } catch (error) {
                console.error('Error loading error distribution:', error);
            }
        }

        async function loadYieldTrends() {
            try {
                const crop = document.getElementById('crop_filter').value;
                const response = await fetch(`/api/yield_trends?crop=${crop}`);
                const data = await response.json();
                
                const trace = {
                    x: data.dates,
                    y: data.yields,
                    mode: 'lines+markers',
                    type: 'scatter',
                    name: 'Yield',
                    line: {
                        color: '#10B981',
                        width: 3
                    },
                    marker: {
                        size: 6,
                        color: '#059669'
                    }
                };
                
                const layout = {
                    title: `Yield Trends${crop !== 'all' ? ' - ' + crop : ''}`,
                    xaxis: { title: 'Date' },
                    yaxis: { title: 'Yield (tons/hectare)' }
                };
                
                Plotly.newPlot('yieldTrendChart', [trace], layout);
            } catch (error) {
                console.error('Error loading yield trends:', error);
            }
        }
    });
</script>
{% endblock %}